<HTML>
<HEAD>
<TITLE>usage(8)</TITLE>
</HEAD>
<BODY>
<H1>usage(8)</H1>
<HR>
<PRE>

</PRE>
<H2>NAME</H2><PRE>
     usage - installing and using Minix


</PRE>
<H2>DESCRIPTION</H2><PRE>
     This manual page describes the installation  and  use  of  Minix  from  a
     System  Administrators point of view.  It contains an installation guide,
     instructions on how to do the initial configuration and some other  info.
     Please  read  this  document entirely before attempting to install Minix.
     The installation  steps  are  in  the  proper  order,  but  not  all  the
     information  you  may  need  is  presented  at  the  right moment.  Other
     detailed information that may be useful  can  be  found  in  <STRONG><A HREF="../man8/boot.8.html">boot(8)</A></STRONG>  and
     <STRONG><A HREF="../man7/hier.7.html">hier(7)</A></STRONG>.

  <STRONG>1.</STRONG> <STRONG>REQUIREMENTS</STRONG>
     The minimum system Minix can be installed on comfortably is an IBM  PC/AT
     or  PS/2  with a 286 processor, 2 Mb memory, a 720 kb diskette drive, and
     30 Mb free space on an AT, ESDI, or SCSI hard disk (the latter controlled
     by  an  Adaptec  1540.)   Minix  for the 386 (Minix-386 for short) can be
     installed on a machine with at least a 386sx processor and 3 Mb memory.

  <STRONG>2.</STRONG> <STRONG>MINIX</STRONG> <STRONG>INSTALLATION</STRONG> <STRONG>BACKGROUND</STRONG>
     The objective of the installation is to create a partition on  your  disk
     and  to put Minix into it.  Minix really requires two partitions however,
     so the single "primary" partition is split into two subpartitions.  The <STRONG>a</STRONG>
     subpartition  will  contain  the root file system, and the <STRONG>c</STRONG> subpartition
     will contain the <STRONG>/usr</STRONG> file system.  What MS-DOS calls "drives",  i.e  C:,
     D:,  E:,  Minix  calls "file systems".  Minix does not use drive letters,
     but requires that one file system is made a part of another  file  system
     by "mounting" one on the other.  The "root" file system is always present
     and starts with the directory "/", the root of the directory  tree.   The
     root  file  system contains a few programs in <STRONG>/bin</STRONG>, device files in <STRONG>/dev</STRONG>,
     and configuration files in <STRONG>/etc</STRONG>.  This is just enough to get  the  system
     started.   Minix  will  soon extend its directory tree by mounting a file
     system on the <STRONG>/usr</STRONG> directory.  What is henceforth known as the /usr  file
     system  contains  all  Minix programs in <STRONG>/usr/bin</STRONG>, file system sources in
     <STRONG>/usr/src</STRONG>, etc, etc.  The ROOT image contains the complete Minix root file
     system,  but  USR  contains  just a small subset of the /usr file system,
     with just enough utilities to install  Minix.   The  complete  /usr  file
     system  is  split  up into the USR.TAZ, SYS.TAZ and CMD.TAZ archives that
     are installed later to fill /usr.

     Let's suppose your first hard disk, which has device name  <STRONG>/dev/hd0</STRONG>,  has
     MS-DOS  already  present  in  the first primary partition (<STRONG>/dev/hd1</STRONG>), and
     some free space left after that.  After Minix is installed in  that  free
     space the disk will look like this:

         /dev/hd0    Whole hard disk #0
           /dev/hd1    MS-DOS C: drive
           /dev/hd2    Minix primary partition
             /dev/hd2a   Minix root partition
             /dev/hd2c   Minix /usr partition

     /dev/hd0 is  the  sum  of  a  partition  table,  /dev/hd1  and  /dev/hd2.
     Likewise  is  /dev/hd2  the  sum  of  a subpartition table, /dev/hd2a and
     /dev/hd2c.  Read the "DEVICES" sections for  more  information  on  Minix
     devices.

  <STRONG>3.</STRONG> <STRONG>INSTALLATION</STRONG>
     You can install Minix automatically or manually as described the sections
     below.  The end result is the same, but manual installation allows one to
     deviate from the preconfigured choices.  You may wish to read the  manual
     pages  of  the  programs used below before you start.  You may especially
     want to read <STRONG><A HREF="../man8/boot.8.html">boot(8)</A></STRONG> if your machine is different from what the  majority
     buys,  because  you  may  need  to set a few boot parameters to configure
     drivers.  To do this type <STRONG>ESC</STRONG> to get to the Boot Monitor prompt, set  the
     appropriate  variables,  use  <STRONG>save</STRONG>  to  store  the  settings  and <STRONG>menu</STRONG> to
     continue where you left off.

     To install the system you need two diskettes: a  bootable  root  diskette
     and  a  diskette  full  of  binaries to use as <STRONG>/usr</STRONG>.  These diskettes are
     named <STRONG>ROOT</STRONG> and <STRONG>USR</STRONG>.  These two diskettes may also be combined on a single
     high density diskette.  In that case the USR part is on the <STRONG>c</STRONG> partition.

     Insert the ROOT diskette, boot the machine and type '=' to the menu.  The
     Minix  kernel  is  loaded  and  takes  control when you see the copyright
     banner.  After loading the root diskette into the RAM disk  you  will  be
     asked to finish the name of the device to mount on <STRONG>/usr</STRONG>.  Type <STRONG>fd0c</STRONG> for a
     diskette that contains both ROOT and USR, otherwise replace ROOT  by  USR
     and type <STRONG>fd0</STRONG>.  Login as <STRONG>root</STRONG>.

  <STRONG>4.</STRONG> <STRONG>AUTOMATIC</STRONG> <STRONG>INSTALLATION</STRONG>
     Type <STRONG>setup</STRONG> to start the installation script.  First it offers to  install
     a  national keyboard map.  The names should be clear, except for <STRONG>us</STRONG>-<STRONG>swap</STRONG>,
     which swaps the CTRL and CAPS LOCK keys of a standard US  style  keyboard
     for  people who believe that the natural place of CTRL is next to A.  The
     default suggested between [ and ] is the US standard keyboard.

     The next thing to do is to make a partition, for this you are placed in a
     partition  table  editor named <STRONG>part</STRONG>.  This partition table editor is very
     easy to use (in the author's opinion), but you  will  probably  hate  it.
     You  can  move all over the place with the arrow keys, change values, and
     make a mess of your partition table real  quick.   So  if  you  get  into
     trouble,  type  'q'  to  quit,  'n' to not write the table, and RETURN to
     start over.  Use the '?' key to get help.

     With the '+' and '-' keys you can select the disk device to  install  on,
     probably  <STRONG>/dev/hd0</STRONG>,  the first hard disk.  Type 'r' to load the partition
     table of the selected disk.  Either create one new partition by modifying
     a partition marked "None", or reuse an existing partition by changing its
     type to "MINIX" (hex code 81).  The FIPS program can be used under MS-DOS
     to shrink an MS-DOS partition.  FIPS splits the DOS partition in two,  so
     one  of  the  two  can be used for Minix.  You have to be absolutely sure
     which one.  When in doubt, first use  the  FDISK  program  under  DOS  to
     delete  the extra partition, and let Minix part create a new one.  DO NOT
     use part to shrink an existing partition!  Minix needs a partition of  at
     least  20  Mb, but not larger than 128 Mb (Minix-86) or 1 Gb (Minix-386).
     The system needs 30 Mb in compiled state.

     The script then wants to know the name of the partition  you've  created,
     this  name  is  probably still visible on the screen (hd2, hd6, something
     like that.)  The new partition table is reloaded into  the  disk  driver,
     and  the  new Minix partition is carved up into two subpartitions, a 1440
     kb root and the rest for /usr.

     After  making  /usr,  it  is  immediately  put  to  use  to  replace  the
     installation /usr file system so that you can remove the USR diskette and
     insert the ROOT diskette (unless they are one and the  same).   The  root
     file system is filled with the contents of the ROOT diskette and slightly
     patched up to work on the hard disk (/etc/fstab.)

     To compute the size of the so-called "second level block cache"  you  are
     asked to specify the RAM size of your machine.  If you have plenty, i.e 4
     Mb or more then simply hit RETURN,  otherwise  enter  the  size  of  your
     system RAM in kilobytes.

     You can now skip the next section and move to "TESTING", but  it  may  be
     instructive to read it anyway.

  <STRONG>5.</STRONG> <STRONG>MANUAL</STRONG> <STRONG>INSTALLATION</STRONG>
     The instructions that follow are at a very low level and require  you  to
     be very careful.  The big advantage is that you know precisely what tools
     have been used and how everything works.  The disadvantage  is  that  you
     may easily make a mistake that either forces you to start over if you are
     lucky, or wipes out the contents of your hard disk if you are not.   Only
     if  you  really  want  to  do something different should you use a manual
     installation.  Slavishly following the steps shown below will  only  make
     you end up with the same result as an automatic installation.

     Run <STRONG>part</STRONG> to make partitions to load the system into.  The best  thing  to
     do  is  to  make one large primary partition of type "MINIX" and to carve
     this partition up into  three  subpartitions  for  root  and  /usr.   The
     assumption  is  that  you will use the second partition on the first hard
     disk, <STRONG>/dev/hd2</STRONG>, and that <STRONG>hd2a</STRONG> is the root subpartition and <STRONG>hd2c</STRONG> is  /usr.
     If  you  want  to  use  the  first  partition on the second hard disk for
     instance, then substitute hd6 and hd6[ac] for the above.  On a SCSI  disk
     it  will  be  /dev/sd2  for the second partition on the disk at target 0.
     See the section on devices below, and the manual pages of <STRONG><A HREF="../man8/part.8.html">part(8)</A></STRONG>, <STRONG><A HREF="../man4/hd.4.html">hd(4)</A></STRONG>,
     and  <STRONG><A HREF="../man4/sd.4.html">sd(4)</A></STRONG>.   Start  <STRONG>part</STRONG>  and  select  the  whole  hard disk device (the
     "multiple of 5" device) that you want to  install  Minix  onto.   In  our
     example it will be <STRONG>/dev/hd0</STRONG>.
     Use <STRONG>part</STRONG> to make a single partition in the  primary  partition  table  of
     type  "MINIX",  then hit '&gt;' on this new partition to make a subpartition
     table.

     For the root subpartition you are advised to use 1440  kb  exactly.   You
     can  make  it larger if you want to, but it is advisable never to let the
     contents outgrow a floppy.  (The ROOT diskette is a copy of a  root  file
     system, and will be used to fill your root subpartition.)

     The second subpartition is either empty or a "scratch" partition.   Minix
     no longer uses the <STRONG>b</STRONG> subpartition for anything useful anymore, but it has
     become customary to have root on <STRONG>a</STRONG> and /usr  on  <STRONG>c</STRONG>.   (You  are  free  to
     ignore this convention, of course.)

     Use the rest of the partition for the /usr <STRONG>c</STRONG> subpartition.

     When you are done check  that  /dev/hd2a  is  active  (the  *  after  the
     partition number) so you can boot from it later.

     If your  disk  has  bad  blocks  then  don't  put  the  root  or  scratch
     subpartition  on  top  of  them.  Make sure the inode tables in the other
     partitions don't have bad blocks either.  You can put  the  subpartitions
     out  of order on the disk if that helps.  Subpartition tables, other than
     the main partition table, are not sorted by the driver.

     After making the partitions you do not have to reboot.  The  disk  driver
     reloads  the  partition  tables  on the next access if the disk is not in
     use.  (Open or mounted.)

     To be able to boot from /dev/hd2a you must place a  master  bootstrap  in
     /dev/hd2.   It  has  been placed there by <STRONG>part</STRONG> if it told you that it was
     creating a new partition table, but

          <STRONG>installboot -m /dev/hd2 /usr/mdec/masterboot</STRONG>

     will put it there for sure.

     You will start by making a file system for /usr and filling it partially.
     This  may  seem  to be out of order, but you can't insert the ROOT floppy
     right now.

          <STRONG>mkfs /dev/hd2c</STRONG>
          <STRONG>readall -b /dev/hd2c</STRONG> <STRONG>|</STRONG> <STRONG>sh</STRONG>
          <STRONG>mount /dev/hd2c /mnt</STRONG>
          <STRONG>cpdir -v /usr /mnt</STRONG>

     This will create a file system on /dev/hd2c, mount it on /mnt,  and  copy
     the  contents  of  the USR floppy onto it.  The call to <STRONG>readall</STRONG> marks bad
     blocks on the file system as unusable, you can omit this on a drive known
     to be spotless (IDE or SCSI.)
     You can now use the new /usr in place of the USR floppy:

          <STRONG>umount /dev/hd2c</STRONG>
          <STRONG>umount /dev/fd0     #</STRONG> <STRONG>fd0c</STRONG> <STRONG>if</STRONG> <STRONG>combined</STRONG>
          <STRONG>mount /dev/hd2c /usr</STRONG>

     This little dance has freed up your floppy drive, so  please  remove  the
     USR diskette and replace it by the ROOT diskette.  Make a file system for
     the root with at least 512 inodes (files), and fill it from the floppy:

          <STRONG>mkfs -i 512 /dev/hd2a</STRONG>
          <STRONG>mount /dev/fd0 /fd0</STRONG>
          <STRONG>mount /dev/hd2a /mnt</STRONG>
          <STRONG>cpdir -v /fd0 /mnt</STRONG>
          <STRONG>umount /dev/fd0</STRONG>

     Remove <STRONG>/mnt/etc/issue</STRONG> to get rid of the "use setup" message  that  greets
     you  when  you boot, and edit the file <STRONG>/mnt/etc/fstab</STRONG> to name the devices
     Minix has been installed on.  In our example it should look like this:

          <STRONG>root=/dev/hd2a</STRONG>
          <STRONG>usr=/dev/hd2c</STRONG>

     Unmount the new root:

          <STRONG>umount /dev/hd2a</STRONG>

     Make it bootable:

          <STRONG>installboot -d /dev/hd2a /usr/mdec/bootblock boot</STRONG>

     The automatic script would now  set  the  <STRONG>rootdev</STRONG>  and  <STRONG>ramimagedev</STRONG>  boot
     variables.   You  can  do  this now using the <STRONG>edparams</STRONG> command, but it is
     easier to postpone it until the testing phase.  The settings should be:

          <STRONG>rootdev=hd2a</STRONG>
          <STRONG>ramimagedev=hd2a</STRONG>

  <STRONG>6.</STRONG> <STRONG>TESTING</STRONG>
     By now a new Minix system is present on your hard disk.  Time to  see  if
     it  works.   Leave the ROOT diskette in the drive and type <STRONG>halt</STRONG>.  You are
     now going to use the power of the Boot Monitor on the  diskette  to  boot
     the  Minix  partition on the hard disk.  Use the monitor command <STRONG>boot</STRONG> <STRONG>hd2</STRONG>
     to boot the primary partition Minix has been installed in.  (It is  "hd2"
     in  our  example.)  For a SCSI disk you will have to use a 'hd' name too.
     The monitor uses the BIOS, so you will have to treat  it  as  a  "normal"
     disk at this point.



     The hard disk bootstrap is now showing the menu again.  You can type  '='
     to start Minix, but you probably want to change the boot parameters.  Hit
     <STRONG>ESC</STRONG> once more to get to the command prompt.  The command <STRONG>set</STRONG>  shows  what
     the  current parameters are.  Here is an example that shows how to make a
     menu to either start Minix or boot MS-DOS:

          <STRONG>minix(=,Minix) {boot}</STRONG>
          <STRONG>dos(d,MS</STRONG>-<STRONG>DOS) {boot hd1}</STRONG>
          <STRONG>save</STRONG>

     MS-DOS is assumed to be in the  first  partition  in  the  example  above
     (hd1).   When  finished  type <STRONG>menu</STRONG> to see if the menu looks right.  If so
     hit '=' to start Minix.

  <STRONG>7.</STRONG> <STRONG>ADDING</STRONG> <STRONG>PROGRAMS</STRONG> <STRONG>AND</STRONG> <STRONG>SOURCES</STRONG> <STRONG>TO</STRONG> <STRONG>/usr</STRONG>
     The <STRONG>setup</STRONG> command can also be used to add files from floppy sets  to  the
     system.   The <STRONG>USR.TAZ</STRONG> (programs and stuff), <STRONG>SYS.TAZ</STRONG> (system sources), and
     <STRONG>CMD.TAZ</STRONG> (commands  sources)  are  all  installed  relative  to  the  <STRONG>/usr</STRONG>
     directory, so the command to use three times is

          <STRONG>setup /usr</STRONG>

     <STRONG>Setup</STRONG> will ask for the size of data on the floppies, which is by  default
     simply  the  entire  floppy.   Don't worry if you see a few "File exists"
     errors while extracting, as some directories already exist.  You need the
     <STRONG>USR.TAZ</STRONG>  set  if  you  want  a  working Minix system, <STRONG>SYS.TAZ</STRONG> if you want
     recompile the system or study it,  and  <STRONG>CMD.TAZ</STRONG>  if  you  also  want  the
     sources  of  the  simple  commands.   On a disk space starved machine you
     could opt to do without the commands sources, as they are not  absolutely
     necessary to understand Minix.

     If your machine does not have enough memory to run <STRONG>setup /usr</STRONG>  then  type
     these commands manually:

          <STRONG>cd /usr</STRONG>
          <STRONG>vol /dev/fd0</STRONG> <STRONG>|</STRONG> <STRONG>uncompress</STRONG> <STRONG>|</STRONG> <STRONG>tar xvfp -</STRONG>

  <STRONG>8.</STRONG> <STRONG>NAMES</STRONG>
     A standalone machine will have to be given a name.  As <STRONG>root</STRONG> type

          <STRONG>echo </STRONG><EM>name</EM><STRONG> &gt;/etc/hostname.file</STRONG>

     to change the host name of your machine to <EM>name</EM>.

  <STRONG>9.</STRONG> <STRONG>ACTIVE</STRONG> <STRONG>ON</STRONG> <STRONG>BOOT</STRONG>
     You  may  want  to  make  the  Minix  partition  active  so  that  it  is
     automatically  booted.   With  DOS  <STRONG>fdisk</STRONG> or Minix <STRONG>part</STRONG>, mark the primary
     partition that contains Minix active.  Using the menu  you  made  earlier
     you  can  boot  either  Minix  or  DOS  at  a keypress.  You can even set
     timeouts.  To boot Minix automatically after 5 seconds:
          <STRONG>main() {trap 5000 minix; menu}</STRONG>

     See <STRONG><A HREF="../man8/monitor.8.html">monitor(8)</A></STRONG> for all the details on the monitor.

     If you don't trust this then you can rig up a  diskette  that  boots  the
     Minix partition when left in the drive:

          <STRONG>installboot -m 2 /dev/fd0 /usr/mdec/masterboot</STRONG>

     The number 2 indicates the hard disk partition that must be  booted,  you
     can use the numbers 1 to 9 for hd1 to hd9.

  <STRONG>10.</STRONG> <STRONG>DEVICES</STRONG>
     A crash course on the Minix devices in <STRONG>/dev</STRONG>:   The  two  hard  disks  are
     named  <STRONG>hd0</STRONG>  and <STRONG>hd5</STRONG>.  These "multiple of five" devices address the entire
     hard disk, from  the  first  to  the  last  byte.   Each  disk  has  four
     partitions,  for  disk 0 they are <STRONG>hd1</STRONG>, <STRONG>hd2</STRONG>, <STRONG>hd3</STRONG>, and <STRONG>hd4</STRONG>.  And for disk 1
     they are named <STRONG>hd6</STRONG>, <STRONG>hd7</STRONG>, <STRONG>hd8</STRONG>, and <STRONG>hd9</STRONG>.  These partitions may contain file
     systems,  <STRONG>hd1</STRONG>  often contains the MS-DOS "C:" file system.  Minix can use
     these partitions for file systems too, but you can also partition one  of
     these  "primary  partitions"  into  four  so-called "subpartitions".  The
     subpartitions of <STRONG>hd1</STRONG> are named <STRONG>hd1a</STRONG>, <STRONG>hd1b</STRONG>, <STRONG>hd1c</STRONG>,  and  <STRONG>hd1d</STRONG>.   The  other
     partitions  may have four subpartitions that are named in the same way by
     adding a letter from <STRONG>a</STRONG> to <STRONG>d</STRONG>.  So one disk may have four  partitions,  and
     16 subpartititions total.  SCSI disks are named in the same way, from <STRONG>sd0</STRONG>
     to <STRONG>sd39d</STRONG> for all possible devices for all eight SCSI  targets.   The  two
     floppy  disks are <STRONG>fd0</STRONG> and <STRONG>fd1</STRONG>.  Each may have four partitions named <STRONG>fd0a</STRONG>,
     <STRONG>fd0b</STRONG>, ...  <STRONG>fd1d</STRONG>.  The command <STRONG>MAKEDEV</STRONG> knows  how  to  make  devices,  and
     <STRONG>DESCRIBE</STRONG>  can  tell  you  what an unknown device may be, or even what all
     devices in  <STRONG>/dev</STRONG>  may  be  if  called  without  arguments.   Devices  are
     described  fully  in <STRONG><A HREF="../man4/dev.4.html">dev(4)</A></STRONG>, and in the device specific manual pages like
     <STRONG><A HREF="../man4/fd.4.html">fd(4)</A></STRONG> and <STRONG><A HREF="../man4/hd.4.html">hd(4)</A></STRONG>.

  <STRONG>11.</STRONG> <STRONG>EDITORS</STRONG>
     The editors available are <STRONG>elvis</STRONG>  (a  <STRONG>vi</STRONG>  clone),  <STRONG>elle</STRONG>  (a  simple  <STRONG>emacs</STRONG>
     clone),  and the old Minix <STRONG>mined</STRONG> editor.  Of these editors only elvis can
     recover your file after a system  crash.   Only  <STRONG>mined</STRONG>  is  available  at
     installation  time.   (All you need to know about mined right now is that
     CTRL-X gets you out of it.)

  <STRONG>12.</STRONG> <STRONG>INSTALLING</STRONG> <STRONG>ON</STRONG> <STRONG>A</STRONG> <STRONG>SCSI</STRONG> <STRONG>DISK</STRONG>
     Using a disk other than a <STRONG>hd</STRONG> disk complicates things  a  bit.   The  Boot
     Monitor  uses  the  BIOS,  so it names all disks with <STRONG>hd</STRONG> names.  So it is
     <STRONG>boot</STRONG> <STRONG>hd1</STRONG> to boot partition 1, and <STRONG>ramimagedev=sd2a</STRONG> to tell Minix its root
     partition.   If you have both a normal and a SCSI disk then the disks may
     be <STRONG>hd0</STRONG> and <STRONG>hd5</STRONG> to the Monitor, and <STRONG>hd0</STRONG> and <STRONG>sd0</STRONG> to Minix.




  <STRONG>13.</STRONG> <STRONG>NATIONAL</STRONG> <STRONG>KEYBOARDS</STRONG>
     The  directory  <STRONG>/usr/lib/keymaps</STRONG>  contains  keymap  tables  for   several
     national keyboards.  If you have a German keyboard for instance, then

          <STRONG>loadkeys /usr/lib/keymaps/german.map</STRONG>

     will load the German key translation  table  into  the  keyboard  driver.
     Copy  the  map  to  <STRONG>/etc/keymap</STRONG> once Minix is installed on the hard disk,
     because having to type a key sequence like one of these:

          <STRONG>loadkezs -usr-lib-kezmaps-german.map</STRONG>
          <STRONG>loqdkeys =usr=lib=key,qps=french.,qp</STRONG>

     on a reboot gets a bit annoying after a while.  Send corrections and  new
     keymaps  to  the  person  named  below.  (Do not send a Dutch keymap, buy
     yourself a real keyboard instead.)


</PRE>
<H2>SUGGESTIONS</H2><PRE>
     Below are a few useful suggestions.  Some of the information  can  be  of
     use in other situations than described here.

  <STRONG>14.</STRONG> <STRONG>VIRTUAL</STRONG> <STRONG>CONSOLES</STRONG>
     Hold down the ALT key and press the left or right arrow key, F1,  or  F2.
     This  switches  the console between two login sessions.  (Unless you have
     an old mono adapter, because virtual consoles sit in video memory, and  a
     mono adapter only has memory for one.)

     Note that kernel messages, including function key output, only appear  on
     the  first  console.   This  may  be  confusing,  but  it keeps the other
     consoles clean.

  <STRONG>15.</STRONG> <STRONG>LOW</STRONG> <STRONG>ON</STRONG> <STRONG>MEMORY</STRONG>
     The normal installation requires that you have enough memory for a  large
     RAM disk.  You can still install Minix normally if you either have a high
     density diskette drive for a combined root+usr floppy, or  you  have  two
     floppy  drives  of  at  least 720 kb.  Before booting you have to set the
     variable <STRONG>rootdev</STRONG> to the same value as <STRONG>ramimagedev</STRONG>.  This is slower then a
     RAM disk, but saves a lot of memory.

     The automatic installation script knows how to handle this new situation.
     If you install manually then you have to use

          <STRONG>cpdir -vx / /mnt</STRONG>

     to copy the root device to disk.  When it is time to fill  /usr  and  you
     only  have  one  floppy drive then hit DEL to get out of the installation
     script and reboot as described in "TESTING".  You  can  then  finish  the
     installation manually.


  <STRONG>16.</STRONG> <STRONG>LOW</STRONG> <STRONG>ON</STRONG> <STRONG>MEMORY</STRONG> <STRONG>AND</STRONG> <STRONG>ONLY</STRONG> <STRONG>ONE</STRONG> <STRONG>720</STRONG> <STRONG>KB</STRONG> <STRONG>FLOPPY</STRONG> <STRONG>DRIVE</STRONG>
     If you only have one 720 kb floppy drive and your system is low on memory
     then  you  can  use the TINYROOT boot image.  This image contains a small
     kernel with only the BIOS disk driver, and a small root file system.  You
     can  use  this disk to boot your machine.  Use the normal ROOT to install
     the root file system.  Keep booting your machine with TINYROOT until  you
     have  compiled  a  small  kernel  for  your system.  Use the <STRONG>rootdev</STRONG> boot
     variable to select the hard disk root file system.  Do <STRONG>not</STRONG>  use  TINYROOT
     for anything other than booting, always use ROOT when mentioned.

  <STRONG>17.</STRONG> <STRONG>FLOPPY</STRONG> <STRONG>DRIVE</STRONG> <STRONG>1</STRONG> <STRONG>IS</STRONG> <STRONG>A</STRONG> <STRONG>HIGH</STRONG> <STRONG>DENSITY</STRONG> <STRONG>DRIVE</STRONG>
     If you would like to install from floppy drive 1 then you need to copy at
     least one sector from the USR image onto a diskette for drive 0.  The USR
     bootstrap has been rigged to boot the other drive.

  <STRONG>18.</STRONG> <STRONG>INSTALLING</STRONG> <STRONG>ON</STRONG> <STRONG>A</STRONG> <STRONG>SECOND</STRONG> <STRONG>HARD</STRONG> <STRONG>DISK</STRONG>
     Minix doesn't care if it is installed on the second disk of a system with
     two  disks.  The only problem is to get it booted.  You can either rig up
     a diskette to boot Minix as shown earlier, or you can use the same  trick
     on the first disk.  The command

          <STRONG>installboot -m 5 /dev/hd0 /usr/mdec/masterboot</STRONG>

     will lock the first disk into booting the second disk.   Note  that  this
     command modifies the disk outside a Minix partition, overwriting a bit of
     code that has likely been put there by DOS fdisk.  First verify that  the
     Boot  Monitor  can  boot  a  DOS partition, because then the Minix master
     bootstrap can do it too.

  <STRONG>19.</STRONG> <STRONG>LOTS</STRONG> <STRONG>OF</STRONG> <STRONG>MEMORY</STRONG> <STRONG>ON</STRONG> <STRONG>A</STRONG> <STRONG>286</STRONG>
     You will have a hard time making Minix run out of 3  Mb  memory.   Memory
     you  can  spare  can  be used for a "second level block cache" on the RAM
     disk.  The File System uses the second level cache  to  store  copies  of
     disk blocks that are pushed out of the normal (primary) block cache.  The
     size of the primary cache is compiled into the FS server, but the size of
     the second level cache can be set with the <STRONG>ramsize</STRONG> boot variable.  Set it
     to a number between 0 and 512.  512 kilobytes is enough to keep  most  of
     the compiler cached.

  <STRONG>20.</STRONG> <STRONG>LOTS</STRONG> <STRONG>OF</STRONG> <STRONG>MEMORY</STRONG> <STRONG>ON</STRONG> <STRONG>A</STRONG> <STRONG>386+</STRONG>
     Processes can be as big as you'd like on a 386, but in practice 4  Mb  is
     nice.  The installation script sets up a second level cache for Minix-386
     of up to 1024 kilobytes.  This is because the default file  system  cache
     is  only  80  kb.   Your  first point of call is to get rid of the poorly
     performing second level cache and to assign the memory used by it to  the
     normal  block  cache by enlarging the appropriate <STRONG>NR_BUFS</STRONG> and <STRONG>NR_BUF_HASH</STRONG>
     constants in &lt;minix/config.h&gt; with as much as you can spare.   (1024  for
     NR_BUFS  is  the minimum to keep <STRONG>cc</STRONG> <STRONG>-c</STRONG> cached.  2048 is then a nice value
     for NR_BUF_HASH.)  Disable the second level cache, compile a new  kernel,
     reboot and set <STRONG>ramsize</STRONG> to 0.

  <STRONG>21.</STRONG> <STRONG>LOTS</STRONG> <STRONG>OF</STRONG> <STRONG>DISK</STRONG> <STRONG>SPACE</STRONG>
     The maximum file system size is 1 Gb for Minix-386 and 128 Mb for  Minix-
     86.   (Minix-86  can  handle  larger  file  systems, but <STRONG>fsck</STRONG> can't check
     them.)  Note that a Minix file  system  can  only  contain  65535  inodes
     (files),  so  the average file should be 16 kb to completely fill it.  It
     may be better to make two smaller  file  systems.   Besides,  fsck  takes
     forever on a large file system.


</PRE>
<H2>SYSTEM ADMINISTRATION</H2><PRE>
     The system has been set up with the idea that working as root  is  a  bad
     thing  to  do.   As  root  you  are in no way protected from doing stupid
     things.  So don't do development as root,  but  work  as  <STRONG>bin</STRONG>!   Only  in
     exceptional  cases  do  you  want  to become root.  Being root is fun for
     wannabe hackers; administrators know better.

     To make life easier for bin, some programs  like  <STRONG><A HREF="../man1/su.1.html">su(1)</A></STRONG>,  <STRONG><A HREF="../man1/install.1.html">install(1)</A></STRONG>  and
     <STRONG><A HREF="../man8/shutdown.8.html">shutdown(8)</A></STRONG>  treat bin and other members of the operator group as special
     and allow them the privileges of root.  (One  is  an  operator  if  one's
     group id is zero.)  Operators should share the shadow password of root by
     having <STRONG>##root</STRONG> in their password field.  This way they all have  one  face
     (password)  to  the  outside world, forming no greater security risk than
     root alone.

     The home directory of bin contains one important Makefile.  You  can  use
     it  to recompile all the commands and libraries of the system.  Type <STRONG>make</STRONG>
     to see the usage message.  If you want to compile just one  command  then
     you  can  simply  type  <STRONG>make</STRONG> to do so.  To put it in its proper place you
     have to type <STRONG>make</STRONG> <STRONG>install</STRONG>.  Read the Makefiles in the  <STRONG>commands</STRONG>  and  <STRONG>lib</STRONG>
     subdirectories  to understand how everything is put together.  If you are
     tight on memory then <STRONG>make</STRONG> may fail to traverse down the source  tree  and
     also  compile  things.   You will have to type <STRONG>make</STRONG> in each subdirectory.
     You can run make in /usr/src at the end to see if you've missed something
     or not.

     The login shell of bin is <STRONG>ash</STRONG>, the BSD shell.  It has  been  modified  to
     offer  simple  line editing using the <STRONG><A HREF="../man3/editline.3.html">editline(3)</A></STRONG> library.  <STRONG>Ash</STRONG> is rather
     big, so you may have to change bin's shell back to <STRONG>/bin/sh</STRONG>  with  <STRONG><A HREF="../man1/chsh.1.html">chsh(1)</A></STRONG>
     if  you are low on memory.  Do not change root's shell to ash, and do not
     replace /bin/sh by ash.  It may run out of memory at the wrong moment.

     The kernel is not compiled from the  master  Makefile.   To  make  a  new
     kernel you have to step into the <STRONG>tools</STRONG> directory.  There you can run four
     different make commands:

     <STRONG>make</STRONG> This makes all the different kernel parts and combines them  in  the
          file named <STRONG>image</STRONG>.

     <STRONG>make</STRONG> <STRONG>fdboot</STRONG>
          As above and then makes a boot floppy that you can  use  to  restart
          your system with.  You are prompted for the floppy device name.

     <STRONG>make</STRONG> <STRONG>hdboot</STRONG>
          First makes the image file and then copies  it  into  the  directory
          <STRONG>/minix</STRONG>.   If there are already two images in that directory then the
          newest image will be removed to make space for this newer image.  It
          is  assumed  that  the oldest image is the most stable system image,
          one that always works, and that the newest  image  is  experimental.
          Check  beforehand  what  <STRONG>/minix</STRONG> contains before you run <STRONG>make</STRONG> <STRONG>hdboot</STRONG>.
          Remove the oldest image if you want  another  image  to  become  the
          stable  image.   The Boot Monitor chooses the newest image in <STRONG>/minix</STRONG>
          to boot.  You can use the monitor  command  <STRONG>ls</STRONG>  <STRONG>minix</STRONG>  to  view  the
          images  present,  and set the <STRONG>image</STRONG> variable to the full name of the
          image you want to use instead  if  the  newest  doesn't  work.   The
          images  in  <STRONG>/minix</STRONG>  are  named  using  the Minix release and version
          numbers with an extra  revision  number  added  to  distinguish  the
          images.

     The first new kernel you would like to make is one  configured  for  your
     system.   The  kernel  you  are  running  now  contains several hard disk
     drivers you don't need, and it does not have a TCP/IP server that you may
     want  to  have.   In &lt;minix/config.h&gt; you can find a number of <STRONG>ENABLE_</STRONG><EM>XXX</EM>
     variables that can be set to <STRONG>0</STRONG> to exclude, or <STRONG>1</STRONG> to include  a  particular
     driver.   Another  driver related variable is <STRONG>DMA_SECTORS</STRONG>.  This variable
     sets the size of a buffer used by DMA based disk  drivers  (all  but  the
     floppy, AT/IDE, and Adaptec drivers).  Raise its value to greatly improve
     throughput, especially writing.  A value of 16 shows good results.   (The
     BIOS  driver  benefits  most,  because  it is a long way to the BIOS from
     protected mode, especially from 286 protected mode.)   You  can  increase
     <STRONG>NR_CONS</STRONG>  if you want to have more virtual consoles.  Having more consoles
     costs little memory, because all the consoles are kept in  video  memory.
     Scrolling  speed  of  the  console  will go down if more virtual consoles
     share the available memory.  CGA cards have space for 4 consoles, EGA and
     VGA can have 8 consoles.  The <STRONG>NR_PTYS</STRONG> variable sets the number of pseudo-
     ttys.  You need pseudo-ttys to be able to login remotely over  a  network
     with the <STRONG>rlogin</STRONG> command.  Each remote login session needs one pseudo-tty.
     If you fear that the system will now run out of processes  then  increase
     <STRONG>NR_PROCS</STRONG>.  Configuring a new kernel is sometimes not enough to enable new
     devices, you sometimes need to use the <STRONG>MAKEDEV</STRONG> command to make new device
     files  in  <STRONG>/dev</STRONG>.   For  pseudo-ttys you also have to check if <STRONG>/etc/ttytab</STRONG>
     mentiones the new devices.

     New additions to the system can be made in the <STRONG>/usr/local</STRONG> tree.  An empty
     directory  tree has been set up for you and binaries and manual pages are
     already in the search paths.  You can make a  new  user  entry  with  the
     <STRONG>adduser</STRONG> command.

     The <STRONG>TZ</STRONG> variable in <STRONG>/etc/profile</STRONG> tells the time zone offset from the  wall
     clock  time  to  GMT.   You  have  to change it for your time zone.  (See
     <STRONG><A HREF="../man5/TZ.5.html">TZ(5)</A></STRONG>.)


     The function keys produce debug dumps, showing various  interesting  data
     about  the system.  F1 lists processes and F5 shows ethernet stats, which
     may be of use now.  Read <STRONG><A HREF="../man4/console.4.html">console(4)</A></STRONG> to know all the details of the screen
     and keyboard.

  <STRONG>22.</STRONG> <STRONG>SYSTEM</STRONG> <STRONG>SHUTDOWN</STRONG>
     You can't just turn a Minix system off.  Minix must be told to flush  the
     modified   data   in   the   file  system  cache  first.   The  following
     commands/keystrokes can be used to exit Minix properly:

     <STRONG>shutdown</STRONG>
          First alert all users  and  then  all  processes  of  the  impending
          shutdown then halt or reboot the system in one of various ways.  See
          <STRONG><A HREF="../man8/shutdown.8.html">shutdown(8)</A></STRONG>.

     <STRONG>reboot</STRONG> <STRONG>/</STRONG> <STRONG>halt</STRONG>
          Alert all processes of the system shutdown then reboot or halt.

     <STRONG>CTRL-ALT-DEL</STRONG>
          Halt the system by running <STRONG>shutdown</STRONG> <STRONG>-h</STRONG> <STRONG>now</STRONG>.

     Minix  halts  by  returning  to  the  Boot  Monitor,  Minix  reboots   by
     instructing  the monitor to reboot Minix.  (Minix is just a subprocess to
     the monitor.)  Either halt Minix  and  use  monitor  commands  to  escape
     Minix, or use <STRONG>shutdown</STRONG> <STRONG>-R</STRONG> to reset the system.


</PRE>
<H2>FILES</H2><PRE>

     <STRONG>/usr/ast</STRONG>    Honorary home directory of Andew S.  Tanenbaum.   Doubles  as
                 the place where the default setup for a new user is found.


</PRE>
<H2>SEE ALSO</H2><PRE>
     <STRONG><A HREF="../man8/monitor.8.html">monitor(8)</A></STRONG>, <STRONG><A HREF="../man8/boot.8.html">boot(8)</A></STRONG>, <STRONG><A HREF="../man8/part.8.html">part(8)</A></STRONG>, <STRONG><A HREF="../man1/mkfs.1.html">mkfs(1)</A></STRONG>, <STRONG><A HREF="../man8/mount.8.html">mount(8)</A></STRONG>, <STRONG><A HREF="../man8/M.8.html">M(8)</A></STRONG>, <STRONG><A HREF="../man5/fstab.5.html">fstab(5)</A></STRONG>, <STRONG><A HREF="../man7/hier.7.html">hier(7)</A></STRONG>,
     <STRONG><A HREF="../man4/console.4.html">console(4)</A></STRONG>, <STRONG><A HREF="../man4/dev.4.html">dev(4)</A></STRONG>, <STRONG><A HREF="../man8/adduser.8.html">adduser(8)</A></STRONG>, <STRONG><A HREF="../man5/TZ.5.html">TZ(5)</A></STRONG>, <STRONG><A HREF="../man8/mkdist.8.html">mkdist(8)</A></STRONG>, <STRONG><A HREF="../man8/shutdown.8.html">shutdown(8)</A></STRONG>.
     "Operating Systems - Design and Implementation" by Andrew S. Tanenbaum.


</PRE>
<H2>NOTES</H2><PRE>
     The  notation  <STRONG>&lt;</STRONG><EM>file</EM><STRONG>.h&gt;</STRONG>  refers  to  a  C  language   include   file   in
     /usr/include.

     <STRONG>Root</STRONG> and <STRONG>bin</STRONG> do not have the current directory in  their  program  search
     path  to  avoid executing programs left around by malicious people.  This
     means that to run <STRONG>foo</STRONG> from the current directory, <STRONG>./foo</STRONG> must be typed.

     Some of the commands have changed  since  earlier  Minix  versions.   For
     instance <STRONG>mkfs</STRONG> doesn't need a size argument anymore, and <STRONG>vol</STRONG> automagically
     determines if it needs to read or write.  Keep this in mind if you use an
     older Minix version to examine the newer system.



</PRE>
<H2>BUGS</H2><PRE>
     There are many PS/2 models, all different.  Some  will  run  Minix,  some
     won't,  some  crippled  if  you  lie to Minix by setting <STRONG>processor</STRONG> to <STRONG>86</STRONG>.
     Almost no PS/2 has a standard disk, so setting <STRONG>hd</STRONG> to <STRONG>esdi</STRONG> or <STRONG>bios</STRONG> will be
     necessary.

     While testing a full library rebuild of this  distribution  it  sometimes
     happened that some things were not put back into the library.  This seems
     to be fixed, but we do not understand why the fix fixed the problem.   So
     if  you  see  strange "undefined" errors when compiling a program after a
     library rebuild then run <STRONG>make</STRONG> <STRONG>install</STRONG> again in <STRONG>/usr/src/lib/</STRONG> to  try  and
     add the missing pieces.

     Except for the floppy driver none of the DMA based drivers know about DMA
     being  limited  to  a  24  bits  address, i.e. the first 16 Mb.  So under
     Minix-386 you run a slight risk that a <STRONG>tar</STRONG> or <STRONG>dd</STRONG> command may use a buffer
     above  16  Mb  for  reading  or writing to a character device.  This only
     happens if the low 16 Mb is taken by some huge processes,  and  you  have
     more than 16 Mb, of course.


</PRE>
<H2>AUTHOR</H2><PRE>
     Kees J. Bot (kjb@cs.vu.nl)




























</PRE>
</BODY>
</HTML>
